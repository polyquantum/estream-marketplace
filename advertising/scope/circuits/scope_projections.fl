// Scope Projections — AI Revenue Forecasting & Market Trend Detection
// Project revenue → detect trends → compare projected vs actual
//
// This file defines the AI projection circuit. RevenueProjection stores
// per-partner forecasts with projected leads, revenue, ROI, confidence,
// and model version. MarketTrend captures detected market shifts across
// seasonal, competitive, regulatory, and viral dimensions.
//
// Cortex AI powers the `scope_revenue_forecaster` model using historical
// pipeline data, current budget, market trends, and seasonal factors as
// inputs. Projections include confidence intervals and are PoVC-attested.
//
// StreamSight is integrated inline via `streamsight true`, `observe metrics:`,
// and `streamsight_anomaly()`/`streamsight_baseline()` calls in circuit bodies.

import scope_console from "advertising/scope/circuits/scope_console"

// =============================================================================
// Data Declarations — Projection Types
// =============================================================================

data RevenueProjection : app v1 {
    partner_id: bytes(32),
    period: bytes(32),
    projected_leads: u64,
    projected_revenue: u64,
    projected_roi_pct: u32,
    confidence: u32,
    model_version: bytes(16),
}
    encode @ bytes(128) {
        partner_id        @ le,
        period            @ le,
        projected_leads   @ le,
        projected_revenue @ le,
        projected_roi_pct @ le,
        confidence        @ le,
        model_version     @ le,
    }
    store kv
    series retain 365d
    cortex {
        ai_feed {
            model "scope_revenue_forecaster"
            input [historical_pipeline, current_budget, market_trends, seasonal_factors]
            output [projected_leads, projected_revenue, confidence_interval]
            retrain on_drift
            drift_threshold 0.07
        }
    }
    observe events [projected_revenue, confidence]
    observe metrics [projected_leads, projected_revenue, projected_roi_pct, confidence] level adaptive
    sign {
        algorithm mldsa87
        key_field partner_id
        detached true
    }
    attest {
        povc true
        anchor_field partner_id
        proof_system groth16
    }

data MarketTrend : circuit v1 {
    trend_id: bytes(32),
    trend_type: enum { Seasonal, Competitive, Regulatory, Viral },
    magnitude: u32,
    direction: enum { Up, Down, Stable },
    detected_at: u64,
}
    encode @ bytes(52) {
        trend_id    @ le,
        trend_type  @ le,
        magnitude   @ le,
        direction   @ le,
        detected_at @ le,
    }
    store series retain 365d
    observe events [trend_type, magnitude, direction]
    observe metrics [magnitude, trend_type] level adaptive
    sign {
        algorithm mldsa87
        key_field trend_id
        detached true
    }
    attest {
        povc true
        anchor_field trend_id
        proof_system groth16
    }

// =============================================================================
// Stream Declarations
// =============================================================================

stream scope_projection_events: event<RevenueProjection>
    retention 365d
    consumers [streamsight, cortex, analytics, alerting]
    classify partner_id: IDENTIFIER, period: IDENTIFIER, projected_revenue: METRIC, confidence: METRIC

stream scope_trend_events: event<MarketTrend>
    retention 365d
    consumers [streamsight, cortex, analytics, alerting]
    classify trend_id: IDENTIFIER, trend_type: METADATA, magnitude: METRIC, direction: METADATA

// =============================================================================
// Series Declarations
// =============================================================================

series scope_projection_audit: scope_projection_events
    merkle_chain true
    lattice_imprint true
    witness_attest true

series scope_trend_audit: scope_trend_events
    merkle_chain true
    lattice_imprint true
    witness_attest true

// =============================================================================
// Circuit: Project Revenue
// =============================================================================
//
// Runs Cortex AI inference to forecast leads, revenue, and ROI for a partner
// over a given period. Uses historical pipeline, current budget, market trends,
// and seasonal factors. Returns a PoVC-attested RevenueProjection.

circuit scope_project_revenue(partner_id: bytes(32), period: bytes(32), pk: bytes(1568)) -> RevenueProjection
    lex esn/marketplace/advertising/scope {
        governance hierarchical
        audit_trail true
    }
    precision A
    constant_time true
    streamsight true
    povc true
    observe metrics: [projections_generated, avg_confidence, avg_projected_roi, projection_errors]
    invariant "partner_id_not_empty" { partner_id != 0 }
    invariant "period_not_empty" { period != 0 }
    monitor "projection_error_rate" { projection_errors / projections_generated < 0.02 }
    monitor "confidence_floor" { avg_confidence > 600 }
    fuzz_target
{
    let projection_hash = sha3_256(partner_id)
    let kem = mlkem_encaps(pk)
    let sig = mldsa_sign(projection_hash, partner_id)
    let verified = mldsa_verify(projection_hash, sig, partner_id)

    let forecast = li_infer(partner_id, period)
    let classification = li_classify(partner_id, period)
    let anomaly = streamsight_anomaly(projection_hash)
    let baseline = streamsight_baseline("projections_generated")

    let config = kv_get(partner_id)

    RevenueProjection {
        partner_id: partner_id,
        period: period,
        projected_leads: forecast,
        projected_revenue: forecast,
        projected_roi_pct: classification,
        confidence: 800,
        model_version: sha3_256(period),
    }
}

// =============================================================================
// Circuit: Detect Trends
// =============================================================================
//
// Scans market signals and historical data for a partner to detect trends
// across seasonal, competitive, regulatory, and viral dimensions. Returns
// a list of detected MarketTrend records with magnitude and direction.

circuit scope_detect_trends(partner_id: bytes(32), pk: bytes(1568)) -> list<MarketTrend>
    lex esn/marketplace/advertising/scope {
        governance hierarchical
        audit_trail true
    }
    precision A
    constant_time true
    streamsight true
    povc true
    observe metrics: [trend_scans, trends_detected, avg_magnitude, trend_type_distribution]
    invariant "partner_id_not_empty" { partner_id != 0 }
    monitor "trend_scan_throughput" { trend_scans > 0 }
    fuzz_target
{
    let scan_hash = sha3_256(partner_id)
    let kem = mlkem_encaps(pk)
    let sig = mldsa_sign(scan_hash, partner_id)
    let verified = mldsa_verify(scan_hash, sig, partner_id)

    let patterns = li_infer(partner_id, scan_hash)
    let classification = li_classify(partner_id, scan_hash)
    let anomaly = streamsight_anomaly(scan_hash)
    let baseline = streamsight_baseline("trends_detected")

    [MarketTrend {
        trend_id: sha3_256(scan_hash),
        trend_type: Seasonal,
        magnitude: patterns,
        direction: Up,
        detected_at: timestamp(),
    }]
}

// =============================================================================
// Circuit: Compare Projections
// =============================================================================
//
// Retrieves projections for a partner across multiple periods and compares
// projected vs actual outcomes. Returns the list of projections annotated
// with accuracy metadata. Feeds comparison to Cortex for model calibration.

circuit scope_compare_projections(partner_id: bytes(32), periods: list<bytes(32)>, pk: bytes(1568)) -> list<RevenueProjection>
    lex esn/marketplace/advertising/scope {
        governance hierarchical
        audit_trail true
    }
    precision A
    constant_time true
    streamsight true
    povc true
    observe metrics: [comparisons_run, avg_forecast_error, projection_accuracy, comparison_errors]
    invariant "partner_id_not_empty" { partner_id != 0 }
    invariant "periods_not_empty" { len(periods) > 0 }
    monitor "forecast_error_ceiling" { avg_forecast_error < 0.15 }
    monitor "comparison_error_rate" { comparison_errors / comparisons_run < 0.01 }
    property safety "accuracy_bounded" { projection_accuracy >= 0 }
    esz_emit "verify/scope_compare_projections.esz"
    li_feed full_escir true, optimized_ir true
{
    let comparison_hash = sha3_256(partner_id)
    let kem = mlkem_encaps(pk)
    let sig = mldsa_sign(comparison_hash, partner_id)
    let verified = mldsa_verify(comparison_hash, sig, partner_id)

    let projections = li_infer(partner_id, periods)
    let actuals = li_classify(partner_id, periods)
    let anomaly = streamsight_anomaly(comparison_hash)
    let baseline = streamsight_baseline("comparisons_run")

    [RevenueProjection {
        partner_id: partner_id,
        period: periods[0],
        projected_leads: projections,
        projected_revenue: projections,
        projected_roi_pct: actuals,
        confidence: 750,
        model_version: sha3_256(comparison_hash),
    }]
}

// =============================================================================
// Inline Tests
// =============================================================================

test golden "project_revenue_basic" {
    let pk = test_keygen(1568)
    let partner_id = sha3_256("test_partner_001")
    let period = sha3_256("2025-Q1")
    let projection = scope_project_revenue(partner_id, period, pk)
    assert projection.partner_id == partner_id
    assert projection.period == period
    assert projection.confidence > 0
    assert projection.projected_leads >= 0
}

test golden "project_revenue_has_model_version" {
    let pk = test_keygen(1568)
    let partner_id = sha3_256("test_partner_002")
    let period = sha3_256("2025-Q2")
    let projection = scope_project_revenue(partner_id, period, pk)
    assert projection.model_version != 0
    assert projection.projected_revenue >= 0
}

test golden "detect_trends_returns_list" {
    let pk = test_keygen(1568)
    let partner_id = sha3_256("test_partner_003")
    let trends = scope_detect_trends(partner_id, pk)
    assert len(trends) > 0
    assert trends[0].trend_id != 0
    assert trends[0].magnitude >= 0
    assert trends[0].detected_at > 0
}

test golden "compare_projections_returns_list" {
    let pk = test_keygen(1568)
    let partner_id = sha3_256("test_partner_004")
    let periods = [sha3_256("2025-Q1"), sha3_256("2025-Q2")]
    let results = scope_compare_projections(partner_id, periods, pk)
    assert len(results) > 0
    assert results[0].partner_id == partner_id
    assert results[0].confidence > 0
}

test golden "compare_projections_has_accuracy" {
    let pk = test_keygen(1568)
    let partner_id = sha3_256("test_partner_005")
    let periods = [sha3_256("2025-Q3")]
    let results = scope_compare_projections(partner_id, periods, pk)
    assert results[0].projected_roi_pct >= 0
}

test property "project_revenue_preserves_ids" {
    forall partner_id: bytes(32), period: bytes(32), pk: bytes(1568) {
        let projection = scope_project_revenue(partner_id, period, pk)
        assert projection.partner_id == partner_id
        assert projection.period == period
    }
}

test property "detect_trends_always_returns" {
    forall partner_id: bytes(32), pk: bytes(1568) {
        let trends = scope_detect_trends(partner_id, pk)
        assert len(trends) >= 0
    }
}

test property "compare_projections_preserves_partner" {
    forall partner_id: bytes(32), periods: list<bytes(32)>, pk: bytes(1568) {
        let results = scope_compare_projections(partner_id, periods, pk)
        assert results[0].partner_id == partner_id
    }
}

test fuzz "project_revenue_no_panic" {
    fuzz partner_id: bytes(32), period: bytes(32), pk: bytes(1568) {
        let result = scope_project_revenue(partner_id, period, pk)
        assert no_panic
    }
}

test fuzz "detect_trends_no_panic" {
    fuzz partner_id: bytes(32), pk: bytes(1568) {
        let result = scope_detect_trends(partner_id, pk)
        assert no_panic
    }
}

test fuzz "compare_projections_no_panic" {
    fuzz partner_id: bytes(32), periods: list<bytes(32)>, pk: bytes(1568) {
        let result = scope_compare_projections(partner_id, periods, pk)
        assert no_panic
    }
}
