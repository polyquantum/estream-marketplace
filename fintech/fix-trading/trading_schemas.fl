// Trading Data Schema Pack — Marketplace Component
// Schema validation, risk checks, and order normalization circuits
//
// Spec: specs/marketplace/FIX_TRADING_COMPONENT_SPEC.md §4
// Parent: specs/marketplace/ESTREAM_MARKETPLACE_SPEC.md §6.2
// Issue: #524 (Phase 3)
//
// The data-trading schema pack provides four core data schemas for capital markets:
//   - EStreamOrder    — Order submission (Buy/Sell, Limit/Market/Stop)
//   - EStreamFill     — Trade execution / fill report
//   - EStreamQuote    — Bid/ask quote
//   - EStreamMarketData — Market data snapshot (OHLCV / BBO)
//
// Schemas are `data` declarations with verbs (observe, govern, sign, attest)
// that generate wire encoding, StreamSight hooks, privacy masks, signing
// envelopes, and PoVC attestation from a single source of truth.
//
// Wire adapters (FIX, SWIFT, etc.) produce these schemas; validation circuits
// enforce their invariants.

// =============================================================================
// Data Declarations — Trading Schemas
// =============================================================================

// Side: 0 = Buy, 1 = Sell
// OrderType: 0 = Market, 1 = Limit, 2 = Stop, 3 = StopLimit
// TimeInForce: 0 = GTC, 1 = IOC, 2 = FOK, 3 = Day

data EStreamOrder : app v1 {
    order_id: bytes(32),
    client_order_id: bytes(64),
    instrument: bytes(32),
    side: u8,
    order_type: u8,
    quantity: u64,
    price: u64,
    time_in_force: u8,
    submitted_at: u64,
    submitter: bytes(32),
}
    encode @ bytes(209) {
        order_id        @ le,
        client_order_id @ le,
        instrument      @ le,
        side            @ le,
        order_type      @ le,
        quantity        @ le,
        price           @ le,
        time_in_force   @ le,
        submitted_at    @ le,
        submitter       @ le,
    }
    observe metrics [quantity, price, side, order_type] level adaptive
    govern {
        PII -> encrypted(auditor)
        IDENTIFIER -> public
        MARKET_DATA -> public
    }
    sign {
        algorithm mldsa87
        key_field submitter
        detached true
    }
    attest {
        povc true
        anchor_field order_id
        proof_system groth16
    }

data EStreamFill : app v1 {
    fill_id: bytes(32),
    order_id: bytes(32),
    instrument: bytes(32),
    side: u8,
    quantity: u64,
    price: u64,
    fee: u64,
    executed_at: u64,
    venue: bytes(32),
}
    encode @ bytes(201) {
        fill_id    @ le,
        order_id   @ le,
        instrument @ le,
        side       @ le,
        quantity   @ le,
        price      @ le,
        fee        @ le,
        executed_at @ le,
        venue      @ le,
    }
    observe metrics [quantity, price, fee] level adaptive
    observe events [fill_id, order_id, instrument]
    attest {
        povc true
        anchor_field fill_id
        proof_system groth16
    }

data EStreamQuote : app v1 {
    instrument: bytes(32),
    bid_price: u64,
    bid_quantity: u64,
    ask_price: u64,
    ask_quantity: u64,
    timestamp: u64,
    source: bytes(32),
}
    observe metrics [bid_price, ask_price, bid_quantity, ask_quantity] level adaptive

data EStreamMarketData : app v1 {
    instrument: bytes(32),
    bid_price: u64,
    bid_quantity: u64,
    ask_price: u64,
    ask_quantity: u64,
    timestamp: u64,
}
    observe metrics [bid_price, ask_price, bid_quantity, ask_quantity] level adaptive

data ValidationResult : circuit v1 {
    valid: bool,
    risk_score: bytes(32),
    rejection_reason: bytes(128),
}
    observe events [valid, rejection_reason]

data RiskLimits : circuit v1 {
    max_order_quantity: u64,
    max_order_value: u64,
    max_position_notional: u64,
    max_daily_orders: u64,
}

// =============================================================================
// Stream Declarations
// =============================================================================

stream trading_orders: event<EStreamOrder>
    | filter record.quantity > 0
    | throttle 50000/s burst 100000
    retention 1y
    classify instrument: MARKET_DATA, side: METADATA, order_id: IDENTIFIER
    consumers [order_router, compliance, analytics]

stream trading_fills: event<EStreamFill>
    retention 1y
    consumers [settlement, reporting, analytics]

stream trading_quotes: event<EStreamQuote>
    | throttle 100000/s burst 500000
    retention 24h
    consumers [pricing_engine, market_data_feed]

stream trading_market_data: event<EStreamMarketData>
    | throttle 100000/s burst 500000
    retention 1y
    consumers [analytics, reporting]

// =============================================================================
// Circuit: Order Validation
// =============================================================================
//
// Validates an EStreamOrder against schema constraints and risk limits.
// This runs on every order before it reaches the lex trading stream.

circuit order_validate(order: EStreamOrder, limits: RiskLimits, pk: bytes(1568)) -> ValidationResult
    lex esn/fin/pci/org/estream/trading {
        governance hierarchical
        audit_trail true
        compliance [pci_dss, mifid2]
    }
    precision A
    constant_time true
    streamsight true
    sanitize pii_fields [order.client_order_id], retention 7y
    observe metrics: [orders_validated, orders_rejected, risk_breaches]
    invariant "quantity_positive" { order.quantity > 0 }
    invariant "side_valid" { order.side <= 1 }
    invariant "order_type_valid" { order.order_type <= 3 }
    invariant "time_in_force_valid" { order.time_in_force <= 3 }
    invariant "limit_order_has_price" { order.order_type != 1 || order.price > 0 }
    monitor "rejection_rate" { orders_rejected / orders_validated < 0.20 }
    fuzz_target
{
    let order_hash = sha3_256(order.order_id)
    let kem = mlkem_encaps(pk)

    let qty_ok = order.quantity > 0 && order.quantity <= limits.max_order_quantity
    let value = order.quantity * order.price
    let value_ok = value <= limits.max_order_value
    let side_ok = order.side <= 1
    let type_ok = order.order_type <= 3
    let tif_ok = order.time_in_force <= 3
    let price_ok = order.order_type == 0 || order.price > 0

    let risk = li_classify(order.order_id, order.instrument)
    let anomaly = streamsight_anomaly(order_hash)

    let all_valid = qty_ok && value_ok && side_ok && type_ok && tif_ok && price_ok

    ValidationResult {
        valid: all_valid,
        risk_score: risk,
        rejection_reason: anomaly,
    }
}

// =============================================================================
// Circuit: Fill Validation
// =============================================================================

circuit fill_validate(fill: EStreamFill) -> bool
    lex esn/fin/pci/org/estream/trading
    precision A
    streamsight true
    observe metrics: [fills_validated, fills_rejected]
    invariant "fill_quantity_positive" { fill.quantity > 0 }
    invariant "fill_price_positive" { fill.price > 0 }
    invariant "fill_has_order_ref" { fill.order_id != 0 }
    kat_vector
{
    let qty_ok = fill.quantity > 0
    let price_ok = fill.price > 0
    let order_ref_ok = fill.order_id != fill.fill_id
    let side_ok = fill.side <= 1
    qty_ok && price_ok && order_ref_ok && side_ok
}

// =============================================================================
// Circuit: Quote Validation
// =============================================================================

circuit quote_validate(quote: EStreamQuote) -> bool
    lex esn/fin/pci/org/estream/trading
    precision B
    streamsight true
    observe metrics: [quotes_validated, crossed_quotes]
    invariant "bid_below_ask" { quote.bid_price <= quote.ask_price }
    invariant "quantities_positive" { quote.bid_quantity > 0 && quote.ask_quantity > 0 }
{
    let spread_ok = quote.ask_price >= quote.bid_price
    let bid_qty_ok = quote.bid_quantity > 0
    let ask_qty_ok = quote.ask_quantity > 0
    let baseline = streamsight_baseline("crossed_quotes")
    spread_ok && bid_qty_ok && ask_qty_ok
}

// =============================================================================
// Circuit: Order Normalization
// =============================================================================

circuit order_normalize(order: EStreamOrder) -> EStreamOrder
    lex esn/fin/pci/org/estream/trading
    precision C
    streamsight true
    observe metrics: [orders_normalized, duplicate_orders_detected]
{
    let canonical_id = sha3_256(order.client_order_id)
    let normalized_instrument = blake3(order.instrument)
    EStreamOrder {
        order_id: canonical_id,
        client_order_id: order.client_order_id,
        instrument: order.instrument,
        side: order.side,
        order_type: order.order_type,
        quantity: order.quantity,
        price: order.price,
        time_in_force: order.time_in_force,
        submitted_at: order.submitted_at,
        submitter: order.submitter,
    }
}

// =============================================================================
// Circuit: Position Risk Check
// =============================================================================

circuit position_risk_check(order: EStreamOrder, current_position: u64, daily_order_count: u64, limits: RiskLimits, pk: bytes(1568)) -> ValidationResult
    lex esn/fin/pci/org/estream/trading {
        governance hierarchical
        audit_trail true
        compliance [pci_dss, mifid2]
    }
    precision A
    constant_time true
    streamsight true
    witness threshold(2, 3)
    observe metrics: [risk_checks, risk_breaches, position_limit_hits, notional_limit_hits]
    invariant "risk_always_checked" { risk_checks >= 1 }
    monitor "breach_rate" { risk_breaches / risk_checks < 0.05 }
    esz_emit "verify/trading_risk.esz"
    li_feed full_escir true, optimized_ir true
{
    let order_hash = sha3_256(order.order_id)
    let kem = mlkem_encaps(pk)
    let notional = order.quantity * order.price
    let new_position = current_position + order.quantity

    let position_ok = new_position <= limits.max_position_notional
    let notional_ok = notional <= limits.max_order_value
    let daily_ok = daily_order_count < limits.max_daily_orders

    let risk = li_infer(order.order_id, order.instrument)
    let anomaly = streamsight_anomaly(order_hash)
    let baseline = streamsight_baseline("risk_breaches")

    let all_ok = position_ok && notional_ok && daily_ok

    ValidationResult {
        valid: all_ok,
        risk_score: risk,
        rejection_reason: anomaly,
    }
}
