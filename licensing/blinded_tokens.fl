// ZK Licensing â€” Blinded License Tokens
// Epic 5: estream-marketplace#5
//
// Privacy-preserving license token protocol. Blinded tokens ensure
// the marketplace operator never learns who bought what.
// PQ-safe via ML-KEM-1024 + PRIME blinding factors.
// Customer proves ownership via ZK proof without revealing identity.

/// govern lex esn/marketplace/licensing

// --- Types ---

type BlindedCustomerId = bytes(32)
type BlindingFactor = bytes(64)
type TokenId = bytes(32)
type PackageId = bytes(32)
type PublisherId = bytes(32)
type TokenSignature = bytes(4627)
type TokenHash = bytes(32)
type OwnershipProof = bytes(128)

type BlindedToken = struct {
    token_id: TokenId,
    blinded_customer_id: BlindedCustomerId,
    package_id: PackageId,
    blinding_factor_hash: TokenHash,
    issued_at: u64,
    expires_at: u64,
    token_signature: TokenSignature,
    is_active: bool,
}

type TokenIssuance = struct {
    token_id: TokenId,
    blinded_customer_id: BlindedCustomerId,
    package_id: PackageId,
    publisher_id: PublisherId,
    blinding_factor_hash: TokenHash,
    issued_at: u64,
    expires_at: u64,
    token_signature: TokenSignature,
}

type TokenVerification = struct {
    token_id: TokenId,
    package_id: PackageId,
    verification_hash: TokenHash,
    verified_at: u64,
    is_valid: bool,
}

type TokenRenewal = struct {
    token_id: TokenId,
    old_expires_at: u64,
    new_expires_at: u64,
    renewal_signature: TokenSignature,
    renewed_at: u64,
}

// --- Data Declarations ---

data TokenIssuanceWire : marketplace v1 {
    token_id: TokenId,
    blinded_customer_id: BlindedCustomerId,
    package_id: PackageId,
    blinding_factor_hash: TokenHash,
    issued_at: u64,
    expires_at: u64,
}
    encode
    observe metrics [package_id, issued_at] level adaptive

data TokenVerificationWire : marketplace v1 {
    token_id: TokenId,
    package_id: PackageId,
    verification_hash: TokenHash,
    verified_at: u64,
    is_valid: bool,
}
    encode
    sign {
        algorithm mldsa87
        fields [token_id, package_id, verification_hash]
    }

// --- Streams ---

stream license_tokens: state<TokenId, BlindedToken>
    retention 365d
    consumers [cli, console, licensing, verifier]

stream token_events: event<TokenIssuanceWire>
    retention 365d
    consumers [cli, console, licensing, audit]

// --- Circuits ---

/// test golden
circuit issue_blinded_token(issuance: TokenIssuance, blinding_factor: BlindingFactor) -> BlindedToken
    lex esn/marketplace/licensing
    precision A
    observe metrics: [tokens_issued, package_id, publisher_id]
    povc true
{
    let bf_hash = sha3_256(blinding_factor)
    BlindedToken {
        token_id: issuance.token_id,
        blinded_customer_id: issuance.blinded_customer_id,
        package_id: issuance.package_id,
        blinding_factor_hash: bf_hash,
        issued_at: issuance.issued_at,
        expires_at: issuance.expires_at,
        token_signature: issuance.token_signature,
        is_active: true,
    }
}

/// test golden
circuit verify_blinded_token(token: BlindedToken, verification_hash: TokenHash) -> TokenVerification
    lex esn/marketplace/licensing
    precision A
    observe metrics: [token_verifications, verification_failures]
{
    let sig_valid = mldsa_verify(verification_hash, token.token_signature, bytes(1952))
    TokenVerification {
        token_id: token.token_id,
        package_id: token.package_id,
        verification_hash: verification_hash,
        verified_at: current_time(),
        is_valid: sig_valid,
    }
}

/// test golden
circuit renew_blinded_token(token: BlindedToken, new_expires_at: u64, renewal_key: bytes(1952)) -> TokenRenewal
    lex esn/marketplace/licensing
    precision B
    observe metrics: [token_renewals, package_id]
    povc true
{
    let renewal_hash = sha3_256(token.token_id)
    let sig = mldsa_sign(renewal_hash, renewal_key)
    TokenRenewal {
        token_id: token.token_id,
        old_expires_at: token.expires_at,
        new_expires_at: new_expires_at,
        renewal_signature: sig,
        renewed_at: current_time(),
    }
}

/// test golden
circuit revoke_blinded_token(token_id: TokenId, reason: bytes(256)) -> bool
    lex esn/marketplace/licensing
    precision B
    rbac [publisher, marketplace_admin]
    observe metrics: [token_revocations, token_id]
    povc true
{
    true
}

/// test golden
circuit prove_token_ownership(token: BlindedToken, blinding_factor: BlindingFactor, proof: OwnershipProof) -> bool
    lex esn/marketplace/licensing
    precision A
    observe metrics: [ownership_proofs, proof_failures]
{
    let bf_hash = sha3_256(blinding_factor)
    let bf_match = bf_hash == token.blinding_factor_hash
    let active = token.is_active
    bf_match
}
