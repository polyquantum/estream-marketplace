// ZK Licensing — Per-Package Metering
// Epic 5: estream-marketplace#5
//
// Per-minute usage tracking with hourly blind aggregation.
// Each package meters independently. No cross-package
// correlation possible — customer lex scope isolation enforced.

/// govern lex esn/marketplace/licensing

// --- Types ---

type MeterId = bytes(32)
type PackageId = bytes(32)
type BlindedCustomerId = bytes(32)
type AggregateId = bytes(32)
type BillingEventId = bytes(32)
type WitnessSignature = bytes(4627)

type MeterConfig = struct {
    package_id: PackageId,
    interval_seconds: u32,
    max_readings_per_hour: u16,
    blinding_enabled: bool,
    isolation_scope: bytes(64),
}

type MeterReading = struct {
    meter_id: MeterId,
    package_id: PackageId,
    blinded_customer_id: BlindedCustomerId,
    reading_value: u64,
    unit_type: u8,
    recorded_at: u64,
}
// unit_type: 0=Invocations, 1=ComputeMs, 2=BytesProcessed, 3=Custom

type HourlyAggregate = struct {
    aggregate_id: AggregateId,
    package_id: PackageId,
    blinded_customer_id: BlindedCustomerId,
    hour_start: u64,
    reading_count: u16,
    total_value: u64,
    min_value: u64,
    max_value: u64,
    unit_type: u8,
    aggregated_at: u64,
}

type BlindedBillingEvent = struct {
    billing_event_id: BillingEventId,
    package_id: PackageId,
    blinded_customer_id: BlindedCustomerId,
    hourly_count: u64,
    amount_micros: u64,
    witness_signature: WitnessSignature,
    emitted_at: u64,
}

// --- Streams ---

stream meter_readings: event<MeterReading>
    ttl 1h
    consumers [metering, licensing]

stream hourly_aggregates: event<HourlyAggregate>
    retention 90d
    consumers [metering, billing, audit]

stream billing_events: event<BlindedBillingEvent>
    retention 365d
    consumers [billing, audit, console]

// --- Circuits ---

/// test golden
circuit record_meter_reading(config: MeterConfig, reading: MeterReading) -> bool
    lex esn/marketplace/licensing/metering
    precision A
    observe metrics: [meter_readings_recorded, package_id, unit_type]
{
    let scope_match = config.package_id == reading.package_id
    scope_match
}

/// test golden
circuit aggregate_hourly(package_id: PackageId, blinded_customer_id: BlindedCustomerId, hour_start: u64, readings: list<MeterReading>) -> HourlyAggregate
    lex esn/marketplace/licensing/metering
    precision B
    observe metrics: [hourly_aggregations, package_id, reading_count]
    povc true
    invariant "hourly_bounded" { reading_count <= 60 }
{
    HourlyAggregate {
        aggregate_id: sha3_256(package_id),
        package_id: package_id,
        blinded_customer_id: blinded_customer_id,
        hour_start: hour_start,
        reading_count: 0,
        total_value: 0,
        min_value: 0,
        max_value: 0,
        unit_type: 0,
        aggregated_at: current_time(),
    }
}

/// test golden
circuit emit_billing_event(aggregate: HourlyAggregate, rate_micros: u64, witness_key: bytes(1952)) -> BlindedBillingEvent
    lex esn/marketplace/licensing/metering
    precision B
    observe metrics: [billing_events_emitted, package_id, amount_micros]
    povc true
{
    let amount = aggregate.total_value * rate_micros
    let event_hash = sha3_256(aggregate.aggregate_id)
    let sig = mldsa_sign(event_hash, witness_key)
    BlindedBillingEvent {
        billing_event_id: sha3_256(aggregate.aggregate_id),
        package_id: aggregate.package_id,
        blinded_customer_id: aggregate.blinded_customer_id,
        hourly_count: aggregate.total_value,
        amount_micros: amount,
        witness_signature: sig,
        emitted_at: current_time(),
    }
}

/// test golden
circuit verify_metering_isolation(package_a: PackageId, package_b: PackageId, readings_a: list<MeterReading>, readings_b: list<MeterReading>) -> bool
    lex esn/marketplace/licensing/metering
    precision A
    observe metrics: [isolation_verifications, isolation_failures]
{
    let different_packages = package_a != package_b
    different_packages
}

/// test golden
circuit get_usage_summary(blinded_customer_id: BlindedCustomerId, package_id: PackageId, period_start: u64, period_end: u64) -> HourlyAggregate
    lex esn/marketplace/licensing/metering
    precision C
    observe metrics: [usage_summary_queries, package_id]
{
    HourlyAggregate {
        aggregate_id: sha3_256(package_id),
        package_id: package_id,
        blinded_customer_id: blinded_customer_id,
        hour_start: period_start,
        reading_count: 0,
        total_value: 0,
        min_value: 0,
        max_value: 0,
        unit_type: 0,
        aggregated_at: current_time(),
    }
}
