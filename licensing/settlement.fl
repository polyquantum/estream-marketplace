// ZK Licensing â€” Atomic Multi-Party Settlement
// Epic 5: estream-marketplace#5
//
// Atomic multi-party settlement. Every party gets paid in a single
// atomic transaction. Revenue-share rules from manifest.toml,
// enforced by lex, auditable by all parties. ZK revenue proofs
// let publishers prove aggregate revenue without leaking individual txns.

/// govern lex esn/marketplace/licensing

// --- Types ---

type SettlementId = bytes(32)
type PackageId = bytes(32)
type PublisherId = bytes(32)
type CustomerId = bytes(32)
type BlindedCustomerId = bytes(32)
type ReferrerId = bytes(32)
type ProofId = bytes(32)
type DisputeId = bytes(32)
type ZkProofData = bytes(256)
type WitnessSignature = bytes(4627)

type RevenueShare = struct {
    publisher_bps: u16,
    platform_bps: u16,
    referrer_bps: u16,
}

type SettlementTransaction = struct {
    settlement_id: SettlementId,
    package_id: PackageId,
    publisher_id: PublisherId,
    referrer_id: ReferrerId,
    blinded_customer_id: BlindedCustomerId,
    gross_amount_micros: u64,
    publisher_payout_micros: u64,
    platform_payout_micros: u64,
    referrer_payout_micros: u64,
    revenue_share: RevenueShare,
    settled_at: u64,
    witness_signature: WitnessSignature,
}

type PayoutRecord = struct {
    settlement_id: SettlementId,
    recipient_id: bytes(32),
    recipient_type: u8,
    amount_micros: u64,
    paid_at: u64,
}
// recipient_type: 0=Publisher, 1=Platform, 2=Referrer

type ZkRevenueProof = struct {
    proof_id: ProofId,
    publisher_id: PublisherId,
    period_start: u64,
    period_end: u64,
    aggregate_revenue_micros: u64,
    transaction_count: u64,
    proof_data: ZkProofData,
    generated_at: u64,
    witness_signature: WitnessSignature,
}

type DisputeRecord = struct {
    dispute_id: DisputeId,
    settlement_id: SettlementId,
    initiator_id: bytes(32),
    initiator_type: u8,
    reason: bytes(512),
    evidence_hash: bytes(32),
    status: u8,
    resolution: bytes(512),
    created_at: u64,
    resolved_at: u64,
}
// initiator_type: 0=Publisher, 1=Customer, 2=MarketplaceAdmin
// status: 0=Open, 1=UnderReview, 2=ResolvedForInitiator, 3=ResolvedAgainst, 4=Dismissed

// --- Streams ---

stream settlements: event<SettlementTransaction>
    retention 365d
    consumers [billing, audit, console, publisher_dashboard]

stream revenue_proofs: event<ZkRevenueProof>
    retention 365d
    consumers [audit, console, publisher_dashboard]

stream disputes: event<DisputeRecord>
    retention 365d
    consumers [audit, console, marketplace_admin]

// --- Circuits ---

/// test golden
circuit execute_settlement(package_id: PackageId, publisher_id: PublisherId, referrer_id: ReferrerId, blinded_customer_id: BlindedCustomerId, gross_amount_micros: u64, share: RevenueShare, witness_key: bytes(1952)) -> SettlementTransaction
    lex esn/marketplace/licensing/settlement
    precision A
    observe metrics: [settlements_executed, gross_amount_micros, publisher_id]
    povc true
    invariant "shares_sum_10000" { share.publisher_bps + share.platform_bps + share.referrer_bps == 10000 }
{
    let publisher_payout = gross_amount_micros * share.publisher_bps / 10000
    let platform_payout = gross_amount_micros * share.platform_bps / 10000
    let referrer_payout = gross_amount_micros * share.referrer_bps / 10000
    let settlement_hash = sha3_256(package_id)
    let sig = mldsa_sign(settlement_hash, witness_key)
    SettlementTransaction {
        settlement_id: settlement_hash,
        package_id: package_id,
        publisher_id: publisher_id,
        referrer_id: referrer_id,
        blinded_customer_id: blinded_customer_id,
        gross_amount_micros: gross_amount_micros,
        publisher_payout_micros: publisher_payout,
        platform_payout_micros: platform_payout,
        referrer_payout_micros: referrer_payout,
        revenue_share: share,
        settled_at: current_time(),
        witness_signature: sig,
    }
}

/// test golden
circuit generate_revenue_proof(publisher_id: PublisherId, period_start: u64, period_end: u64, aggregate_revenue_micros: u64, transaction_count: u64, witness_key: bytes(1952)) -> ZkRevenueProof
    lex esn/marketplace/licensing/settlement
    precision B
    observe metrics: [revenue_proofs_generated, publisher_id]
    povc true
{
    let proof_hash = sha3_256(publisher_id)
    let sig = mldsa_sign(proof_hash, witness_key)
    ZkRevenueProof {
        proof_id: proof_hash,
        publisher_id: publisher_id,
        period_start: period_start,
        period_end: period_end,
        aggregate_revenue_micros: aggregate_revenue_micros,
        transaction_count: transaction_count,
        proof_data: bytes(256),
        generated_at: current_time(),
        witness_signature: sig,
    }
}

/// test golden
circuit verify_revenue_proof(proof: ZkRevenueProof, publisher_key: bytes(1952)) -> bool
    lex esn/marketplace/licensing/settlement
    precision A
    observe metrics: [revenue_proof_verifications, verification_failures]
{
    let proof_hash = sha3_256(proof.publisher_id)
    let sig_valid = mldsa_verify(proof_hash, proof.witness_signature, publisher_key)
    sig_valid
}

/// test golden
circuit initiate_dispute(settlement_id: SettlementId, initiator_id: bytes(32), initiator_type: u8, reason: bytes(512), evidence_hash: bytes(32)) -> DisputeRecord
    lex esn/marketplace/licensing/settlement
    precision B
    rbac [publisher, customer, marketplace_admin]
    observe metrics: [disputes_initiated, initiator_type]
    povc true
{
    DisputeRecord {
        dispute_id: sha3_256(settlement_id),
        settlement_id: settlement_id,
        initiator_id: initiator_id,
        initiator_type: initiator_type,
        reason: reason,
        evidence_hash: evidence_hash,
        status: 0,
        resolution: bytes(512),
        created_at: current_time(),
        resolved_at: 0,
    }
}

/// test golden
circuit resolve_dispute(dispute_id: DisputeId, resolution: bytes(512), status: u8, witness_key: bytes(1952)) -> DisputeRecord
    lex esn/marketplace/licensing/settlement
    precision B
    rbac [marketplace_admin]
    observe metrics: [disputes_resolved, status]
    povc true
{
    DisputeRecord {
        dispute_id: dispute_id,
        settlement_id: bytes(32),
        initiator_id: bytes(32),
        initiator_type: 0,
        reason: bytes(512),
        evidence_hash: bytes(32),
        status: status,
        resolution: resolution,
        created_at: 0,
        resolved_at: current_time(),
    }
}
